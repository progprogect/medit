# Create Scenario — Идеальный сценарий (Target Flow)

**Версия:** 1.0  
**Дата:** 2025-02-22  
**Область:** Вкладка «Create Scenario» (без B-roll вкладки)

---

## 1. Обзор идеального flow

```
┌─────────────────┐     ┌─────────────────────────────────┐     ┌─────────────────────────────────┐
│ 1. Входные данные│────▶│ 2. Генерация сценария            │────▶│ 3. Дополнение недостающих кусков  │
│ Медиа + prompt   │     │ LLM → сцены + таймлайн           │     │ VEO / сток (пользователь вручную)│
└─────────────────┘     └─────────────────────────────────┘     └─────────────────────────────────┘
                                                                              │
                                                                              ▼
┌─────────────────┐     ┌─────────────────────────────────┐     ┌─────────────────────────────────┐
│ 5. Итоговое видео│◀────│ 4. Рендер (объединение)          │◀────│ Проверка: все сегменты готовы?   │
│ download_url     │     │ LLM → задачи FFmpeg → Executor   │     │ Нет → запросить до рендера      │
└─────────────────┘     └─────────────────────────────────┘     └─────────────────────────────────┘
```

---

## 2. Этапы (детально)

### Этап 1: Входные данные

- Пользователь загружает медиа (видео, изображения) в проект
- Вводит общий prompt
- Опционально: референс (Instagram/YouTube)

---

### Этап 2: Генерация сценария

- **Действие:** «Сгенерировать сценарий»
- **Результат:** набор сцен + таймлайн (слои, сегменты)
- **Текущее состояние:** работает, сцены и таймлайн отображаются

**Выход этапа 2:**
- `Scenario`: сцены + слои (video, audio, text) + сегменты с таймингами
- Сегменты: `asset_source` (uploaded | generated), `asset_status` (ready | pending)

---

### Этап 3: Дополнение недостающих кусков

- Сегменты с `asset_status=pending` требуют контент (B-roll)
- **Пользователь вручную:** выбирает «Сгенерировать (VEO3)» или «Найти в стоке» для каждой сцены
- После генерации: сегмент получает `asset_id`, `asset_status=ready`

**Текущее состояние:** реализовано, пользователь делает это сам вручную.

---

### Этап 4: Рендер (объединение по сценарию)

**Когда пользователь нажимает «Сгенерировать итоговое видео»:**

1. **Проверка готовности:** все сегменты с `asset_source=generated` должны иметь `asset_status=ready`
   - Если есть pending → **не начинать рендер**
   - Показать пользователю: «Сначала сгенерируйте или найдите в стоке: [список сцен]»
   - Или: автоматически запросить недостающие (VEO/сток) до рендера

2. **Генерация задач FFmpeg:** LLM получает сценарий + ассеты и формирует список задач
   - **Как в Редакторе:** `/analyze` возвращает `tasks` (JSON), executor их выполняет
   - **Вход для LLM:** Scenario (scenes, layers, segments) + маппинг asset_id → file_path
   - **Выход:** `tasks: [{ type, params, output_id?, inputs? }]`

3. **Исполнение:** `run_tasks(input_path, tasks, output_path, initial_registry)`
   - `initial_registry`: main video + B-roll clips (asset_id → path)
   - Executor выполняет задачи последовательно (overlay_video, add_text_overlay, concat и т.д.)

4. **Результат:** `output_key`, `download_url`

---

### Этап 5: Итоговое видео

- Пользователь скачивает результат по ссылке

---

## 3. Ключевые отличия от текущей реализации

| Аспект | Сейчас | Идеально |
|--------|--------|----------|
| **Задачи для рендера** | `scenario_to_render_tasks()` — детерминированная Python-функция | LLM генерирует задачи (как в Редакторе) |
| **Проверка перед рендером** | Кнопка активна при `hasMainVideo()` | Все сегменты с generated должны быть ready |
| **Недостающие сцены** | Рендер может fetch из стока при overlay | Запросить/показать ошибку ДО рендера |

---

## 4. Предлагаемая архитектура рендера

### 4.1 Вариант A: LLM генерирует задачи

```
POST /api/projects/{id}/scenario/render
  → Проверка: все сегменты ready?
  → Если нет: 400 + список pending
  → Если да:
      → scenario_to_llm_tasks(scenario, assets)  # подготовка контекста
      → LLM: "Generate FFmpeg tasks for this scenario" → tasks
      → run_tasks(source, tasks, output, registry)
      → return download_url
```

**Плюсы:** гибкость, расширяемость, единообразие с Редактором  
**Минусы:** недетерминированность, нужна валидация tasks

### 4.2 Вариант B: Гибрид (LLM + валидация)

- LLM генерирует задачи
- Python-валидатор проверяет: все типы из whitelist, params корректны

### 4.3 Вариант C: Детерминированный (текущий)

- Оставить `scenario_to_render_tasks()` как есть
- Добавить только: проверку готовности перед рендером + авто-запрос недостающих

---

## 5. Обязательная проверка перед рендером

**Правило:** перед вызовом рендера все сегменты с `asset_source=generated` должны иметь `asset_status=ready`.

**Реализация:**

1. **Проверка готовности:** `scenario.layers` → video_layer.segments → для каждого с `asset_source=generated` проверить `asset_status=ready`
2. **Если есть pending:**
   - **Вариант 1:** вернуть 400 с сообщением: «Сначала сгенерируйте или найдите в стоке для сцен: [X, Y, Z]»
   - **Вариант 2:** автоматически запросить (VEO или stock) для каждого pending, затем рендер

---

## 6. Схема данных для LLM (если вариант A/B)

**Вход для LLM при рендере:**

```json
{
  "scenario": {
    "metadata": { "total_duration_sec": 48, "aspect_ratio": "9:16" },
    "scenes": [...],
    "layers": [
      {
        "type": "video",
        "segments": [
          { "id": "seg_main_0", "start_sec": 0, "end_sec": 12, "asset_id": "asset-1", "asset_source": "uploaded" },
          { "id": "seg_broll_1", "start_sec": 12, "end_sec": 17, "asset_id": "asset-2", "asset_source": "uploaded" }
        ]
      },
      { "type": "audio", "segments": [...] }
    ]
  },
  "assets": {
    "asset-1": "uploads/proj/asset-1/main.mp4",
    "asset-2": "uploads/proj/asset-2/broll.mp4"
  },
  "main_asset_id": "asset-1"
}
```

**Выход LLM:** `tasks: [{ type: "overlay_video", params: { start_time, end_time, stock_id }, ... }, ...]`

---

## 7. Рекомендации (без исправлений)

1. **Зафиксировать:** этот документ как target spec для Create Scenario tab.

2. **Проверка готовности:** добавить проверку перед рендером — обязательна в любом варианте.

3. **Авто-запрос недостающих:** решить — блокировать рендер (400) или автоматически запрашивать. Рекомендация: сначала блокировать с понятным сообщением, позже — опция «автоматически подставить».

4. **LLM vs Python для задач:** решить между A/B/C. Для MVP можно оставить C (детерминированный) + проверку готовности. Для гибкости — двигаться к A/B.

5. **Единообразие с Редактором:** если LLM генерирует задачи — использовать тот же executor и те же типы задач (add_text_overlay, overlay_video, trim, concat и т.д.).
